[
  {
    "path": "posts/welcome/",
    "title": "Welcome to RetinaCartoon",
    "description": "Welcome to our new blog, RetinaCartoon. We hope you enjoy \nreading what we have to say!",
    "author": [
      {
        "name": "Nora Jones",
        "url": "https://example.com/norajones"
      }
    ],
    "date": "2021-09-07",
    "categories": [],
    "contents": "\n\n\n\n",
    "preview": {},
    "last_modified": "2021-09-07T10:59:41-07:00",
    "input_file": {}
  },
  {
    "path": "posts/RetinaCartoon/",
    "title": "RetinaCartoon Vignette",
    "description": {},
    "author": [
      {
        "name": "Drew Voigt",
        "url": {}
      }
    ],
    "date": "2021-09-01",
    "categories": [],
    "contents": "\nUsing R to Create Cartoon Heatmaps\nIn my research, I have found it really valuable to draw summary ‘cartoon’ figures that summarize some part of anatomy/physiology that I am studying. While these overview figures have been great for papers and presentations, I have often wanted to interact with these figures within R itself. I thought it would be useful to recolor parts of the cartoon (specifically different cell populations in a tissue) according to some quantitative characteristic (in my case, this was usally gene expression information).\nMy desire to interact with cartoons in R has been especially strong when analyzing data from single-cell RNA sequencing experiments. When analyzing this data, it is often useful to visualize gene expression mapped over a cloud of tSNE or UMAP coordinates. However, my colleagues and collaborators wouldn’t always find these plots helpful, as the position of the clusters weren’t always intuitive for someone looking at the data for the first time. Therefore, I decided to find a way to plot a cartoon of our tissue of interest (in this example, the choroid, a vascular connective tissue underlying the retina) and map expression in each cluster to a cell type depicted in the cartoon. In this vignette, I will show you how to replicate this process. This will be especially of interest to folks working with scRNA-seq data, however the first parts of this vignette can be applied anytime you’d like to interact with an image in R.\nDISCLAIMER: When I embarked on this project, I tried to tackle it in a single day. The approach works, but requires multiple steps. Sometimes, I employed simple solutions like for-loops instead of more elegant mapping commands. I believe this increases readability and shouldn’t result in decrease in performance (unless you have drawn a Sistine-chapel-level-of-detail cartoon!!) There are likely cleaner or simpler approaches to this problem, but I still believe this vignette has value worth sharing. The following approach may not be the best way, but it is a way to interact with hand-drawn cartoons in R!\nPart 1: Drawing your cartoon\nFirst, we need to create a cartoon drawing. I create my cartoons in Adobe Illustrator, but one could also create a cartoon in Microsoft Powerpoint. A couple of notes about these cartoons:\nEvery subcomponent of the cartoon that you want to interact with in R needs its own color. For my research, a ‘subcomponent’ means a cell type. Therefore, I colored all of the capillary endothelial cells in my cartoon the exact same shade of purple.\nFor each object, I added a narrow black outline (this is purely stylistic).\nI saved the cartoon as a .pdf file\nI will share the PDF of file of the cartoon used to make this vignette on my github: www.github.com/drewvoigt10/RetinaCartoon/vignette/images/choroid_cartoon.pdf\nIn order to read this image into R, we need to convert it to an XML file. Converting a PDF to an XML file requires generating an intermediate image in the form of a PostScript File.\nPart 2: Converting the PDF to a PostScript File to an XML file\nI used a free online conversion tool to convert the PDF file to a PostScript File: https://convertio.co/pdf-ps/. This is a great tool (and does not require any sort of sign up), but the free version only allows for 10 file conversions a day.\nNext, I used the grImport package in R to convert the PostScript file to an XML file. I have a macbook, and grImport requires installation of ‘ghostscript,’ which is not available for MacOS. Therefore, I performed this step on my University’s High Performance Computing Cluster, although a free AWS instance would also work well. I’ll also load the rest of the libraries we will need for this vignette.\n\n\nlibrary(grImport)\nlibrary(tidyverse)\nlibrary(cowplot)\nlibrary(grDevices)\nlibrary(ggpubr)\nlibrary(here)\n\nPostScriptTrace(here(\"_posts/RetinaCartoon/images/choroid_cartoon.ps\"))\n\n\n\nRunning PostScriptTrace created a file called choroid_cartoon.ps.xml in the same directory as my original PostScript file. I transferred this new XML file back to my local machine (where I also installed the grImport package). This XML file is also available on my github: www.github.com/drewvoigt10/RetinaCartoon/vignette/images/choroid_cartoon.ps.xml\nPart 3: Classifying each cartoon subcomponent in R\nUsing the readPicture() function from the grImport package, we can read in the XML file into an object class called “PictureFill.” This object class has slots for x/y coordinates of lines (used to draw an individual subcomponents in the cartoon) as well as color information, line width, etc.\n\n\nmy_cartoon <- readPicture(here(\"_posts/RetinaCartoon/images/choroid_cartoon.ps.xml\"))\n\n\n\nLet’s look at the structure of an element in this PictureFill object\n\n\nstr(my_cartoon@paths[1]$path)\n\n\nFormal class 'PictureFill' [package \"grImport\"] with 9 slots\n  ..@ rule     : chr \"nonzero\"\n  ..@ x        : Named num [1:235] 1004 1004 1004 1005 1006 ...\n  .. ..- attr(*, \"names\")= chr [1:235] \"move\" \"line\" \"line\" \"line\" ...\n  ..@ y        : Named num [1:235] 665 664 661 655 646 ...\n  .. ..- attr(*, \"names\")= chr [1:235] \"move\" \"line\" \"line\" \"line\" ...\n  ..@ rgb      : chr \"#80CC28\"\n  ..@ lty      : num(0) \n  ..@ lwd      : num 10\n  ..@ lineend  : num 1\n  ..@ linejoin : num 1\n  ..@ linemitre: num 10\n\nWe can see that each path in this PictureFill object has many slots. The slot that is of most interest to us is the @rgb slot, which contains the HEX color code of the cartoon subcomponent (ie cells).\nWe want to capture and store all of the colors for all subcomponents (ie, cells) in my_cartoon. We will use these colors to identify the index of all cartoon subcomponents (ie, cells). So, we will go through in a for-loop and pull out the rgb HEX color code for each element in my_cartoon, storing this in the vector all_colors. Note that in the conversion of our file, HEX color codes can slightly change, so we unfortunately can’t look up the HEX color codes we used in PPT or Adobe Illustrator.\n\n\n# we will use a quick-and-dirty for loop to grab all colors from our cartoon object \n# and store them in the vector all_colors\nall_colors <- c() \n\nfor(i in 1:length(my_cartoon@paths)){\n  if(.hasSlot(my_cartoon@paths[i]$path, \"rgb\")){ ## some parts of the cartoon (like simple \n                                                 ## lines) may not have a color slot, so we add a catch\n    \n    color <- my_cartoon@paths[i]$path@rgb        ## pluck off the color\n    \n    all_colors <- c(all_colors, color)           ## add the color to the vector all_colors\n    \n  } else {                                       ## if the path does not have an associated color, we \n                                                 ## add an empty string\n                                                 ## to not throw off the index\n    color <- \"\"\n    all_colors <- c(all_colors, color)\n  }\n\n}\n\nunique_colors <- data.frame(color = unique(all_colors)) %>% filter(color != \"\")\n\n# plot the colors so that you can look them up and manually map back to the picture\nunique_colors %>% \n  mutate(x_index = 1) %>%\n  ggplot(aes(x = x_index, y = color)) +\n    geom_tile(aes(fill = color)) +\n    scale_fill_manual(values = sort(unique_colors$color))\n\n\n\n\nCreating our dictionary\nNow, we can create a dictionary that maps each color to a cell type. We have to do this by hand, sadly, by comparing the above ggplot to the cartoon drawing we generated in Part 1.\n\n\ncolor_celltype_tibble <- tribble(~hex_color, ~celltype,\n                                 \"#F9B0B0\", \"smc\", \n                                 \"#F9A72B\", \"schwann-mye\",  \n                                 \"#EA8AED\", \"macrophage-res\", \n                                 \"#E92822\", \"artery\", \n                                 \"#D3AADA\", \"rpechor-pericyte\", \n                                 \"#D1B619\", \"dendritic\", \n                                 \"#BBE49B\", \"melanocyte\", \n                                 \"#B4CBFF\", \"t-cell\",\n                                 \"#9C1661\", \"b-cell\", \n                                 \"#8346EB\", \"macrophage-inflam\", \n                                 \"#80CC28\", \"fibroblast\", \n                                 \"#782F9A\", \"choriocapillaris\",\n                                 \"#22275D\", \"vein\"\n                                 )\n\n\n\nHow to re-color individual parts of your cartoon (a brief example)\nThese next few sections are provided to show you how we can use this newly-defined dictionary to recolor a specific cell type of interest. This logic will be folded into the function generate_cartoon_data() in Part 4. In brief, we have a PictureFill object that contains one element for each subcomponent (individual cell) in our large cartoon. We can pluck off the HEX color codes from each of these elements and store these colors in a vector. Then, we can use our newly defined color_celtype_tibble to link each of these colors to a cell type. By knowing the color of each element in our PictureFill object, we also know what cell type that element is referencing.\nFirst, we create a function to search through our object for each of the above colors. When we find a match, we store the index - this index tells us which cell type is being drawn! We will use this function below to match colors with indexes in the PictureFill object, using our newly-defined dictionary to link the cartoon and cell type names together.\n\n\n# returns the indexes of all paths matching each HEX color in a vector\nmatch_colors_and_indexes <- function(color_celltype_tibble, celltype, all_colors){\n  # color_celltype_tibble = dictionary of hexcode colors and celltypes\n  # celltype = column name in the tibble with the annotated celltype\n  # all_colors = all extracted colors from the PictureFill (Cartoon) Object\n  celltype_index <- which(color_celltype_tibble[[\"celltype\"]] == celltype)\n  my_vector <- which(all_colors == color_celltype_tibble[[\"hex_color\"]][celltype_index])\n  return(my_vector)\n}\n\n\n\nRemember that our cartoon has been processed as a PictureFill object, which is similar to a list. Each element of the list corresponds to a different contiguous sub-shape in the cartoon. Our goal is to identify which shape corresponds to which cell type. We can do this by scrolling through each element of our PictureFill object, finding that object’s color, and matching that against our color-celltype dictionary using the above function.\n\n\n# We will create an empty list\n# Each element in the list corresponds to a different celltype\n# Each element in the list is a VECTOR, which corresponds to the path index(es) corresponding \n# to each celltype\ncelltype_indexes <- vector(mode = \"list\", length = nrow(color_celltype_tibble))\nnames(celltype_indexes) <- color_celltype_tibble[[\"celltype\"]]\n\n## This for loop will fill in the indexes for each celltype\nfor(i in 1:length(celltype_indexes)){\n  index_vector <- match_colors_and_indexes(color_celltype_tibble = color_celltype_tibble,\n                                           celltype = color_celltype_tibble[[\"celltype\"]][i],\n                                           all_colors = all_colors)\n  celltype_indexes[[i]] <- index_vector\n}\n\ncelltype_indexes\n\n\n$smc\n[1] 51 53\n\n$`schwann-mye`\n[1] 11 15 47\n\n$`macrophage-res`\n[1] 209 212 215 273\n\n$artery\n[1] 23 25 27 29\n\n$`rpechor-pericyte`\n[1]  5  7 33\n\n$dendritic\n[1] 245 248 251 254\n\n$melanocyte\n[1] 55 57 59\n\n$`t-cell`\n[1]   3   9  31  45 206\n\n$`b-cell`\n[1]  80  84  88 202\n\n$`macrophage-inflam`\n[1] 259 262 265 268\n\n$fibroblast\n[1]   1 198 200\n\n$choriocapillaris\n[1] 19 21 35 41 43\n\n$vein\n[1] 37 39\n\ncelltype_indexes$melanocyte\n\n\n[1] 55 57 59\n\nHooray! We have finished the hard part. We see from this list of indexes that the 55th, 57th, and 59th elements in my_cartoon are all melanocytes. For demonstration, can plot one of these elements with cowplot and the grImport function pictureGrob:\n\n\ncowplot::plot_grid(\n  pictureGrob(my_cartoon[[55]]) # we can see from celltype_indexes$melanocyte \n                                # that the 55th element of my_cartoon is a melanocyte!\n)\n\n\n\n\nWe can now change the color of this object easily, which will help us create a heatmap of gene expression\n\n\nmy_recolored_cartoon <- my_cartoon[[55]]\nmy_recolored_cartoon@paths$path@rgb <- \"pink\"\n\ncowplot::plot_grid(\n  pictureGrob(my_recolored_cartoon)\n)\n\n\n\n\nPart 4: Mapping single-cell expression data to this cartoon\nLet’s review what we’ve done so far. We have drawn a cartoon, converted this cartoon to a xml file (through an intermediate post script file), extracted all of the colors from this cartoon, created a dictionary that matches colors with their cell types, and scrolled through the cartoon to map each element in the PictureFill list to a cell type.\nNow the fun begins - we can start recoloring these cells based on gene expression!\nI use the Seurat R package to analyze my scRNA-seq data. Instead of uploading the entire gigantic Seurat object to this vignette, I will simply show you how I summarized the expression for each of my cell types and then upload a subset of this expression matrix to my github here: www.github.com/drewvoigt10/RetinaCartoon/vignette/avg_exp_choroid_vignette.csv\n\n\n#Idents(seurat_obj) <- \"celltype\" # note: names of cell types should EXACTLY match\n                                  # the names in color_celltype_tibble above\n# avg_exp <- AverageExpression(seurat_obj, assays = \"RNA\")$RNA %>% \n#  data.frame() %>% \n#  rownames_to_column(\"gene_name\")\n\n# ensure column names (celltypes) EXACTLY match the above dictionary\n\n# saved as avg_exp_choroid_vignette.csv\n\navg_exp <- read_csv(here(\"_posts/RetinaCartoon/avg_exp_choroid_vignette.csv\"))\navg_exp\n\n\n# A tibble: 14 x 16\n   gene_name  artery    vein choriocapillaris unknown_ec `schwann-mye`\n   <chr>       <dbl>   <dbl>            <dbl>      <dbl>         <dbl>\n 1 SEMA3G    4.42e+0 5.66e-2         0.286       0.233         0.123  \n 2 ACKR1     3.06e-1 2.05e+1         7.06        2.06          0.300  \n 3 CA4       4.10e-1 9.57e-1        18.5         0.518         0.0438 \n 4 VWF       1.35e+1 4.09e+1        34.1        12.4           0.506  \n 5 PLP1      1.56e-2 1.78e-2         0.00382     0.0762       16.4    \n 6 MLANA     3.63e-2 2.53e-2         0.0307      0.689         0.0916 \n 7 APOD      3.21e-1 4.75e-1         0.404       4.93          1.30   \n 8 ACTG2     1.27e-3 2.85e-3         0.000394    0.0142        0      \n 9 CCL19     5.31e-2 4.87e-1         0.186       0.261         0.0527 \n10 CD79A     9.23e-3 9.72e-3         0.0226      0.00256       0.00958\n11 CD2       4.58e-3 5.34e-3         0.00508     0.0168        0.00281\n12 C1QC      6.06e-2 9.14e-2         0.0915      0.279         0.225  \n13 S100A8    3.88e-1 6.08e-1         0.290       0.502         0.249  \n14 HLA-DQA1  5.10e-1 1.46e+0         1.46        0.548         0.0873 \n# … with 10 more variables: melanocyte <dbl>, fibroblast <dbl>,\n#   smc <dbl>, rpechor-pericyte <dbl>, rod_rpe <dbl>, b-cell <dbl>,\n#   t-cell <dbl>, macrophage-res <dbl>, macrophage-inflam <dbl>,\n#   dendritic <dbl>\n\nFirst, we will create a function to re-color each cartoon subcomponent based on gene expression. This function will return a list of (1) our modified (re-colored) XML object and (2) a custom color legend. This is a somewhat long function, but I have documented each component below.\n\n\ngenerate_cartoon_data <- function(gene,\n                                  xml_object, \n                                  expression_matrix,\n                                  color_celltype_dictionary,\n                                  color = \"red\"){\n  # gene: character string of the gene name for expression visualization\n  # xml_object: grImport Picture Object\n  # expression_matrix: a dataframe with gene expression information. Rows = genes, \n  #                    columns  = cell types. Gene names must be stored in a column\n  #                    named 'gene_name'\n  # color_celltype_dictionary: a dictionary (like generated in part 2) that maps\n  #                            every colorin the xml_object to a celltype\n  # color: character string that indicates the color used for the expression visualization\n  \n\n  ### (1) Filter the expression matrix for your gene \n  expression_df <- expression_matrix %>%\n    dplyr::filter(gene_name == gene) %>%\n    tibble::column_to_rownames(\"gene_name\") %>%\n    t() %>%\n    as.data.frame() %>%\n    tibble::rownames_to_column(\"celltype\")\n  \n  colnames(expression_df)[2] <- \"expression\"\n  \n  ### (2) Find the upper limit of gene expression for your scale\n  max_expression <- max(expression_df[,2])\n  max_expression <- max_expression + 1  # adding 1 to  max expression makes visualizations\n                                        # for lowly expressed genes more accurate\n  \n  ### (3) Create a blended color scale. Grey = low expression. \n  ###    The user-defined variable `color` = high expression\n  colfunc <- grDevices::colorRampPalette(c(\"grey\", color))\n  my_colors <- colfunc(101)\n  \n  expression_df <- expression_df %>%\n    dplyr::mutate(percent = round(expression * 100 / max_expression)) %>%\n    dplyr::mutate(color = my_colors[as.integer(percent + 1)])\n  \n  ### (4) Creating a legend of expression\n  expression_sequenced <- data.frame(\n    expression = seq(from = 0,\n                     to = max_expression,\n                     by = max_expression/100),\n    my_colors)\n  \n  heatmap_legend <- ggplot2::ggplot(expression_sequenced) +\n    ggplot2::geom_tile(aes(x = 1, y = expression, fill = expression)) +\n    ggplot2::scale_fill_gradient(low = my_colors[1],\n                        high = my_colors[101]) +\n    ggplot2::scale_x_continuous(limits=c(0,2),breaks=1, labels = \"expression\")\n  \n  leg <- ggpubr::get_legend(heatmap_legend)\n  \n  \n  ### (5) Generate cell type indexes (as shown in Part 3, above)\n  celltype_indexes <- vector(mode = \"list\", length = nrow(color_celltype_dictionary))\n  names(celltype_indexes) <- color_celltype_dictionary[[\"celltype\"]]\n  \n  ## This for loop will fill in the indexes for each celltype\n  for(i in 1:length(celltype_indexes)){\n    index_vector <- match_colors_and_indexes(color_celltype_tibble = color_celltype_dictionary,\n                                             celltype = color_celltype_dictionary[[\"celltype\"]][i],\n                                             all_colors = all_colors)\n    celltype_indexes[[i]] <- index_vector\n  }\n\n  \n  ### (6) Re-color the object based on the EXPRESSION color scale\n  # (re-coloring modifies the original XML object)\n  for(i in 1:nrow(expression_df)){\n    celltype <- expression_df[[\"celltype\"]][i]      ## grab our celltype\n    indexes <- unlist(celltype_indexes[[celltype]]) ## identify the indexes of this celltype\n    color <- expression_df[[\"color\"]][i]            ## grab the color based on the scale in (3)\n    \n    if(length(indexes) > 0){\n      for(p in 1:length(indexes)){                  ## for each index, replace the @rgb colot\n          xml_object@paths[indexes[p]]$path@rgb  <- color\n      }\n    }\n  }\n  \n  return(list(xml_object, leg))  ## return the modified XML object and the custom legend\n\n}\n\n\n\nDefining a wrapper function for plotting\nFinally, we will create a simple function to plot our cartoon. This function requires an input ‘cartoon_data’ - a list which is generated by the above function!\n\n\nplot_cartoon <- function(cartoon_data){\n  cowplot::plot_grid(\n    grImport::pictureGrob(cartoon_data[[1]]),\n    cartoon_data[[2]],\n    ncol = 2,\n    rel_widths = c(0.8, 0.2)\n  )\n}\n\n\n\nPart 5: Let’s make some Cartoon Plots!\nFirst, we visualize expression of CA4, which localizes to choriocapillaris endothelial cells.\n\n\ngenerate_cartoon_data(\n  gene = \"CA4\",\n  xml_object = my_cartoon,\n  expression_matrix = avg_exp,\n  color_celltype_dictionary = color_celltype_tibble,\n  color = \"red\"\n) %>%\n  plot_cartoon()\n\n\n\n\nWe can change the color of the expression scale to green simply by modifying the color argument in generatate_cartoon_data\n\n\ngenerate_cartoon_data(\n  gene = \"CA4\",\n  xml_object = my_cartoon,\n  expression_matrix = avg_exp,\n  color_celltype_dictionary = color_celltype_tibble,\n  color = \"green\"\n) %>%\n  plot_cartoon()\n\n\n\n\nFinally, let’s visualize the expression of the melanocyte-specific gene, MLANA\n\n\ngenerate_cartoon_data(\n  gene = \"MLANA\",\n  xml_object = my_cartoon,\n  expression_matrix = avg_exp,\n  color_celltype_dictionary = color_celltype_tibble,\n  color = \"red\"\n) %>%\n  plot_cartoon()\n\n\n\n\nI hope this vignette helps you interact with hand-drawn cartoons in R!\n\n\n\n",
    "preview": "posts/RetinaCartoon/distill-preview.png",
    "last_modified": "2021-09-07T11:06:13-07:00",
    "input_file": "Retina_Cartoon_vignette.knit.md"
  }
]
